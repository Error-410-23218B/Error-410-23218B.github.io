"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _buffer = require("./buffer.js");
var n = require("./node/index.js");
var _t = require("@babel/types");
var _tokenMap = require("./token-map.js");
var generatorFunctions = require("./generators/index.js");
var isExpression = _t.isExpression,
  isFunction = _t.isFunction,
  isStatement = _t.isStatement,
  isClassBody = _t.isClassBody,
  isTSInterfaceBody = _t.isTSInterfaceBody,
  isTSEnumDeclaration = _t.isTSEnumDeclaration;
var SCIENTIFIC_NOTATION = /e/i;
var ZERO_DECIMAL_INTEGER = /\.0+$/;
var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
var HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
function commentIsNewline(c) {
  return c.type === "CommentLine" || HAS_NEWLINE.test(c.value);
}
var needsParens = n.needsParens;
var Printer = /*#__PURE__*/function () {
  function Printer(format, map, tokens, originalCode) {
    _classCallCheck(this, Printer);
    this.inForStatementInit = false;
    this.tokenContext = 0;
    this._tokens = null;
    this._originalCode = null;
    this._currentNode = null;
    this._indent = 0;
    this._indentRepeat = 0;
    this._insideAux = false;
    this._noLineTerminator = false;
    this._noLineTerminatorAfterNode = null;
    this._printAuxAfterOnNextUserNode = false;
    this._printedComments = new Set();
    this._endsWithInteger = false;
    this._endsWithWord = false;
    this._endsWithDiv = false;
    this._lastCommentLine = 0;
    this._endsWithInnerRaw = false;
    this._indentInnerComments = true;
    this.tokenMap = null;
    this._boundGetRawIdentifier = this._getRawIdentifier.bind(this);
    this.format = format;
    this._tokens = tokens;
    this._originalCode = originalCode;
    this._indentRepeat = format.indent.style.length;
    this._inputMap = map == null ? void 0 : map._inputMap;
    this._buf = new _buffer["default"](map, format.indent.style[0]);
  }
  return _createClass(Printer, [{
    key: "enterForStatementInit",
    value: function enterForStatementInit() {
      var _this = this;
      if (this.inForStatementInit) return function () {};
      this.inForStatementInit = true;
      return function () {
        _this.inForStatementInit = false;
      };
    }
  }, {
    key: "enterDelimited",
    value: function enterDelimited() {
      var _this2 = this;
      var oldInForStatementInit = this.inForStatementInit;
      var oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
      if (oldInForStatementInit === false && oldNoLineTerminatorAfterNode === null) {
        return function () {};
      }
      this.inForStatementInit = false;
      this._noLineTerminatorAfterNode = null;
      return function () {
        _this2.inForStatementInit = oldInForStatementInit;
        _this2._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
      };
    }
  }, {
    key: "generate",
    value: function generate(ast) {
      if (this.format.preserveFormat) {
        this.tokenMap = new _tokenMap.TokenMap(ast, this._tokens, this._originalCode);
      }
      this.print(ast);
      this._maybeAddAuxComment();
      return this._buf.get();
    }
  }, {
    key: "indent",
    value: function indent() {
      var format = this.format;
      if (format.preserveFormat || format.compact || format.concise) {
        return;
      }
      this._indent++;
    }
  }, {
    key: "dedent",
    value: function dedent() {
      var format = this.format;
      if (format.preserveFormat || format.compact || format.concise) {
        return;
      }
      this._indent--;
    }
  }, {
    key: "semicolon",
    value: function semicolon() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this._maybeAddAuxComment();
      if (force) {
        this._appendChar(59);
        this._noLineTerminator = false;
        return;
      }
      if (this.tokenMap) {
        var node = this._currentNode;
        if (node.start != null && node.end != null) {
          if (!this.tokenMap.endMatches(node, ";")) {
            return;
          }
          var indexes = this.tokenMap.getIndexes(this._currentNode);
          this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);
        }
      }
      this._queue(59);
      this._noLineTerminator = false;
    }
  }, {
    key: "rightBrace",
    value: function rightBrace(node) {
      if (this.format.minified) {
        this._buf.removeLastSemicolon();
      }
      this.sourceWithOffset("end", node.loc, -1);
      this.tokenChar(125);
    }
  }, {
    key: "rightParens",
    value: function rightParens(node) {
      this.sourceWithOffset("end", node.loc, -1);
      this.tokenChar(41);
    }
  }, {
    key: "space",
    value: function space() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var format = this.format;
      if (format.compact || format.preserveFormat) return;
      if (force) {
        this._space();
      } else if (this._buf.hasContent()) {
        var lastCp = this.getLastChar();
        if (lastCp !== 32 && lastCp !== 10) {
          this._space();
        }
      }
    }
  }, {
    key: "word",
    value: function word(str) {
      var noLineTerminatorAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.tokenContext = 0;
      this._maybePrintInnerComments(str);
      if (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) {
        this._space();
      }
      this._maybeAddAuxComment();
      this._append(str, false);
      this._endsWithWord = true;
      this._noLineTerminator = noLineTerminatorAfter;
    }
  }, {
    key: "number",
    value: function number(str, _number) {
      function isNonDecimalLiteral(str) {
        if (str.length > 2 && str.charCodeAt(0) === 48) {
          var secondChar = str.charCodeAt(1);
          return secondChar === 98 || secondChar === 111 || secondChar === 120;
        }
        return false;
      }
      this.word(str);
      this._endsWithInteger = Number.isInteger(_number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
    }
  }, {
    key: "token",
    value: function token(str) {
      var maybeNewline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var occurrenceCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.tokenContext = 0;
      this._maybePrintInnerComments(str, occurrenceCount);
      var lastChar = this.getLastChar();
      var strFirst = str.charCodeAt(0);
      if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
        this._space();
      }
      this._maybeAddAuxComment();
      this._append(str, maybeNewline, occurrenceCount);
      this._noLineTerminator = false;
    }
  }, {
    key: "tokenChar",
    value: function tokenChar(_char) {
      this.tokenContext = 0;
      this._maybePrintInnerComments(String.fromCharCode(_char));
      var lastChar = this.getLastChar();
      if (_char === 43 && lastChar === 43 || _char === 45 && lastChar === 45 || _char === 46 && this._endsWithInteger) {
        this._space();
      }
      this._maybeAddAuxComment();
      this._appendChar(_char);
      this._noLineTerminator = false;
    }
  }, {
    key: "newline",
    value: function newline() {
      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var force = arguments.length > 1 ? arguments[1] : undefined;
      if (i <= 0) return;
      if (!force) {
        if (this.format.retainLines || this.format.compact) return;
        if (this.format.concise) {
          this.space();
          return;
        }
      }
      if (i > 2) i = 2;
      i -= this._buf.getNewlineCount();
      for (var j = 0; j < i; j++) {
        this._newline();
      }
      return;
    }
  }, {
    key: "endsWith",
    value: function endsWith(_char2) {
      return this.getLastChar() === _char2;
    }
  }, {
    key: "getLastChar",
    value: function getLastChar() {
      return this._buf.getLastChar();
    }
  }, {
    key: "endsWithCharAndNewline",
    value: function endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
  }, {
    key: "removeTrailingNewline",
    value: function removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
  }, {
    key: "exactSource",
    value: function exactSource(loc, cb) {
      if (!loc) {
        cb();
        return;
      }
      this._catchUp("start", loc);
      this._buf.exactSource(loc, cb);
    }
  }, {
    key: "source",
    value: function source(prop, loc) {
      if (!loc) return;
      this._catchUp(prop, loc);
      this._buf.source(prop, loc);
    }
  }, {
    key: "sourceWithOffset",
    value: function sourceWithOffset(prop, loc, columnOffset) {
      if (!loc || this.format.preserveFormat) return;
      this._catchUp(prop, loc);
      this._buf.sourceWithOffset(prop, loc, columnOffset);
    }
  }, {
    key: "sourceIdentifierName",
    value: function sourceIdentifierName(identifierName, pos) {
      if (!this._buf._canMarkIdName) return;
      var sourcePosition = this._buf._sourcePosition;
      sourcePosition.identifierNamePos = pos;
      sourcePosition.identifierName = identifierName;
    }
  }, {
    key: "_space",
    value: function _space() {
      this._queue(32);
    }
  }, {
    key: "_newline",
    value: function _newline() {
      this._queue(10);
    }
  }, {
    key: "_append",
    value: function _append(str, maybeNewline) {
      var occurrenceCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (this.tokenMap) {
        var token = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);
        if (token) this._catchUpTo(token.loc.start);
      }
      this._maybeIndent(str.charCodeAt(0));
      this._buf.append(str, maybeNewline);
      this._endsWithWord = false;
      this._endsWithInteger = false;
      this._endsWithDiv = false;
    }
  }, {
    key: "_appendChar",
    value: function _appendChar(_char3) {
      if (this.tokenMap) {
        var token = this.tokenMap.findMatching(this._currentNode, String.fromCharCode(_char3));
        if (token) this._catchUpTo(token.loc.start);
      }
      this._maybeIndent(_char3);
      this._buf.appendChar(_char3);
      this._endsWithWord = false;
      this._endsWithInteger = false;
      this._endsWithDiv = false;
    }
  }, {
    key: "_queue",
    value: function _queue(_char4) {
      this._maybeIndent(_char4);
      this._buf.queue(_char4);
      this._endsWithWord = false;
      this._endsWithInteger = false;
    }
  }, {
    key: "_maybeIndent",
    value: function _maybeIndent(firstChar) {
      if (this._indent && firstChar !== 10 && this.endsWith(10)) {
        this._buf.queueIndentation(this._getIndent());
      }
    }
  }, {
    key: "_shouldIndent",
    value: function _shouldIndent(firstChar) {
      if (this._indent && firstChar !== 10 && this.endsWith(10)) {
        return true;
      }
    }
  }, {
    key: "catchUp",
    value: function catchUp(line) {
      if (!this.format.retainLines) return;
      var count = line - this._buf.getCurrentLine();
      for (var i = 0; i < count; i++) {
        this._newline();
      }
    }
  }, {
    key: "_catchUp",
    value: function _catchUp(prop, loc) {
      var format = this.format;
      if (!format.preserveFormat) {
        if (format.retainLines && loc != null && loc[prop]) {
          this.catchUp(loc[prop].line);
        }
        return;
      }
      var pos = loc == null ? void 0 : loc[prop];
      if (pos != null) this._catchUpTo(pos);
    }
  }, {
    key: "_catchUpTo",
    value: function _catchUpTo(_ref) {
      var line = _ref.line,
        column = _ref.column,
        index = _ref.index;
      var count = line - this._buf.getCurrentLine();
      if (count > 0 && this._noLineTerminator) {
        return;
      }
      for (var i = 0; i < count; i++) {
        this._newline();
      }
      var spacesCount = count > 0 ? column : column - this._buf.getCurrentColumn();
      if (spacesCount > 0) {
        var spaces = this._originalCode ? this._originalCode.slice(index - spacesCount, index).replace(/(?:[\0-\x08\n\r-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, " ") : " ".repeat(spacesCount);
        this._append(spaces, false);
      }
    }
  }, {
    key: "_getIndent",
    value: function _getIndent() {
      return this._indentRepeat * this._indent;
    }
  }, {
    key: "printTerminatorless",
    value: function printTerminatorless(node) {
      this._noLineTerminator = true;
      this.print(node);
    }
  }, {
    key: "print",
    value: function print(node, noLineTerminatorAfter, trailingCommentsLineOffset) {
      var _node$extra, _node$leadingComments, _node$leadingComments2;
      if (!node) return;
      this._endsWithInnerRaw = false;
      var nodeType = node.type;
      var format = this.format;
      var oldConcise = format.concise;
      if (node._compact) {
        format.concise = true;
      }
      var printMethod = this[nodeType];
      if (printMethod === undefined) {
        throw new ReferenceError("unknown node of type ".concat(JSON.stringify(nodeType), " with constructor ").concat(JSON.stringify(node.constructor.name)));
      }
      var parent = this._currentNode;
      this._currentNode = node;
      var oldInAux = this._insideAux;
      this._insideAux = node.loc == null;
      this._maybeAddAuxComment(this._insideAux && !oldInAux);
      var parenthesized = (_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized;
      var shouldPrintParens = parenthesized && format.preserveFormat || parenthesized && format.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node, parent, this.tokenContext, this.inForStatementInit, format.preserveFormat ? this._boundGetRawIdentifier : undefined);
      if (!shouldPrintParens && parenthesized && (_node$leadingComments = node.leadingComments) != null && _node$leadingComments.length && node.leadingComments[0].type === "CommentBlock") {
        var parentType = parent == null ? void 0 : parent.type;
        switch (parentType) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (parent.callee !== node) break;
          default:
            shouldPrintParens = true;
        }
      }
      var indentParenthesized = false;
      if (!shouldPrintParens && this._noLineTerminator && ((_node$leadingComments2 = node.leadingComments) != null && _node$leadingComments2.some(commentIsNewline) || this.format.retainLines && node.loc && node.loc.start.line > this._buf.getCurrentLine())) {
        shouldPrintParens = true;
        indentParenthesized = true;
      }
      var oldNoLineTerminatorAfterNode;
      var oldInForStatementInitWasTrue;
      if (!shouldPrintParens) {
        noLineTerminatorAfter || (noLineTerminatorAfter = parent && this._noLineTerminatorAfterNode === parent && n.isLastChild(parent, node));
        if (noLineTerminatorAfter) {
          var _node$trailingComment;
          if ((_node$trailingComment = node.trailingComments) != null && _node$trailingComment.some(commentIsNewline)) {
            if (isExpression(node)) shouldPrintParens = true;
          } else {
            oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
            this._noLineTerminatorAfterNode = node;
          }
        }
      }
      if (shouldPrintParens) {
        this.tokenChar(40);
        if (indentParenthesized) this.indent();
        this._endsWithInnerRaw = false;
        if (this.inForStatementInit) {
          oldInForStatementInitWasTrue = true;
          this.inForStatementInit = false;
        }
        oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
        this._noLineTerminatorAfterNode = null;
      }
      this._lastCommentLine = 0;
      this._printLeadingComments(node, parent);
      var loc = nodeType === "Program" || nodeType === "File" ? null : node.loc;
      this.exactSource(loc, printMethod.bind(this, node, parent));
      if (shouldPrintParens) {
        this._printTrailingComments(node, parent);
        if (indentParenthesized) {
          this.dedent();
          this.newline();
        }
        this.tokenChar(41);
        this._noLineTerminator = noLineTerminatorAfter;
        if (oldInForStatementInitWasTrue) this.inForStatementInit = true;
      } else if (noLineTerminatorAfter && !this._noLineTerminator) {
        this._noLineTerminator = true;
        this._printTrailingComments(node, parent);
      } else {
        this._printTrailingComments(node, parent, trailingCommentsLineOffset);
      }
      this._currentNode = parent;
      format.concise = oldConcise;
      this._insideAux = oldInAux;
      if (oldNoLineTerminatorAfterNode !== undefined) {
        this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
      }
      this._endsWithInnerRaw = false;
    }
  }, {
    key: "_maybeAddAuxComment",
    value: function _maybeAddAuxComment(enteredPositionlessNode) {
      if (enteredPositionlessNode) this._printAuxBeforeComment();
      if (!this._insideAux) this._printAuxAfterComment();
    }
  }, {
    key: "_printAuxBeforeComment",
    value: function _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = true;
      var comment = this.format.auxiliaryCommentBefore;
      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        }, 0);
      }
    }
  }, {
    key: "_printAuxAfterComment",
    value: function _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = false;
      var comment = this.format.auxiliaryCommentAfter;
      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        }, 0);
      }
    }
  }, {
    key: "getPossibleRaw",
    value: function getPossibleRaw(node) {
      var extra = node.extra;
      if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node.value === extra.rawValue) {
        return extra.raw;
      }
    }
  }, {
    key: "printJoin",
    value: function printJoin(nodes) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!(nodes != null && nodes.length)) return;
      var indent = opts.indent;
      if (indent == null && this.format.retainLines) {
        var _nodes$0$loc;
        var startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;
        if (startLine != null && startLine !== this._buf.getCurrentLine()) {
          indent = true;
        }
      }
      if (indent) this.indent();
      var newlineOpts = {
        addNewlines: opts.addNewlines,
        nextNodeStartLine: 0
      };
      var separator = opts.separator ? opts.separator.bind(this) : null;
      var len = nodes.length;
      for (var i = 0; i < len; i++) {
        var node = nodes[i];
        if (!node) continue;
        if (opts.statement) this._printNewline(i === 0, newlineOpts);
        this.print(node, undefined, opts.trailingCommentsLineOffset || 0);
        opts.iterator == null || opts.iterator(node, i);
        if (separator != null) {
          if (i < len - 1) separator(i, false);else if (opts.printTrailingSeparator) separator(i, true);
        }
        if (opts.statement) {
          var _node$trailingComment2;
          if (!((_node$trailingComment2 = node.trailingComments) != null && _node$trailingComment2.length)) {
            this._lastCommentLine = 0;
          }
          if (i + 1 === len) {
            this.newline(1);
          } else {
            var _nextNode$loc;
            var nextNode = nodes[i + 1];
            newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;
            this._printNewline(true, newlineOpts);
          }
        }
      }
      if (indent) this.dedent();
    }
  }, {
    key: "printAndIndentOnComments",
    value: function printAndIndentOnComments(node) {
      var indent = node.leadingComments && node.leadingComments.length > 0;
      if (indent) this.indent();
      this.print(node);
      if (indent) this.dedent();
    }
  }, {
    key: "printBlock",
    value: function printBlock(parent) {
      var node = parent.body;
      if (node.type !== "EmptyStatement") {
        this.space();
      }
      this.print(node);
    }
  }, {
    key: "_printTrailingComments",
    value: function _printTrailingComments(node, parent, lineOffset) {
      var innerComments = node.innerComments,
        trailingComments = node.trailingComments;
      if (innerComments != null && innerComments.length) {
        this._printComments(2, innerComments, node, parent, lineOffset);
      }
      if (trailingComments != null && trailingComments.length) {
        this._printComments(2, trailingComments, node, parent, lineOffset);
      }
    }
  }, {
    key: "_printLeadingComments",
    value: function _printLeadingComments(node, parent) {
      var comments = node.leadingComments;
      if (!(comments != null && comments.length)) return;
      this._printComments(0, comments, node, parent);
    }
  }, {
    key: "_maybePrintInnerComments",
    value: function _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
      if (this._endsWithInnerRaw) {
        var _this$tokenMap;
        this.printInnerComments((_this$tokenMap = this.tokenMap) == null ? void 0 : _this$tokenMap.findMatching(this._currentNode, nextTokenStr, nextTokenOccurrenceCount));
      }
      this._endsWithInnerRaw = true;
      this._indentInnerComments = true;
    }
  }, {
    key: "printInnerComments",
    value: function printInnerComments(nextToken) {
      var node = this._currentNode;
      var comments = node.innerComments;
      if (!(comments != null && comments.length)) return;
      var hasSpace = this.endsWith(32);
      var indent = this._indentInnerComments;
      var printedCommentsCount = this._printedComments.size;
      if (indent) this.indent();
      this._printComments(1, comments, node, undefined, undefined, nextToken);
      if (hasSpace && printedCommentsCount !== this._printedComments.size) {
        this.space();
      }
      if (indent) this.dedent();
    }
  }, {
    key: "noIndentInnerCommentsHere",
    value: function noIndentInnerCommentsHere() {
      this._indentInnerComments = false;
    }
  }, {
    key: "printSequence",
    value: function printSequence(nodes) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _opts$indent;
      opts.statement = true;
      (_opts$indent = opts.indent) != null ? _opts$indent : opts.indent = false;
      this.printJoin(nodes, opts);
    }
  }, {
    key: "printList",
    value: function printList(items) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (opts.separator == null) {
        opts.separator = commaSeparator;
      }
      this.printJoin(items, opts);
    }
  }, {
    key: "shouldPrintTrailingComma",
    value: function shouldPrintTrailingComma(listEnd) {
      var _this3 = this;
      if (!this.tokenMap) return null;
      var listEndIndex = this.tokenMap.findLastIndex(this._currentNode, function (token) {
        return _this3.tokenMap.matchesOriginal(token, listEnd);
      });
      if (listEndIndex <= 0) return null;
      return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ",");
    }
  }, {
    key: "_printNewline",
    value: function _printNewline(newLine, opts) {
      var format = this.format;
      if (format.retainLines || format.compact) return;
      if (format.concise) {
        this.space();
        return;
      }
      if (!newLine) {
        return;
      }
      var startLine = opts.nextNodeStartLine;
      var lastCommentLine = this._lastCommentLine;
      if (startLine > 0 && lastCommentLine > 0) {
        var offset = startLine - lastCommentLine;
        if (offset >= 0) {
          this.newline(offset || 1);
          return;
        }
      }
      if (this._buf.hasContent()) {
        this.newline(1);
      }
    }
  }, {
    key: "_shouldPrintComment",
    value: function _shouldPrintComment(comment, nextToken) {
      if (comment.ignore) return 0;
      if (this._printedComments.has(comment)) return 0;
      if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {
        return 2;
      }
      if (nextToken && this.tokenMap) {
        var commentTok = this.tokenMap.find(this._currentNode, function (token) {
          return token.value === comment.value;
        });
        if (commentTok && commentTok.start > nextToken.start) {
          return 2;
        }
      }
      this._printedComments.add(comment);
      if (!this.format.shouldPrintComment(comment.value)) {
        return 0;
      }
      return 1;
    }
  }, {
    key: "_printComment",
    value: function _printComment(comment, skipNewLines) {
      var noLineTerminator = this._noLineTerminator;
      var isBlockComment = comment.type === "CommentBlock";
      var printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
      if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
        this.newline(1);
      }
      var lastCharCode = this.getLastChar();
      if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {
        this.space();
      }
      var val;
      if (isBlockComment) {
        val = "/*".concat(comment.value, "*/");
        if (this.format.indent.adjustMultilineComment) {
          var _comment$loc;
          var offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
          if (offset) {
            var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
            val = val.replace(newlineRegex, "\n");
          }
          if (this.format.concise) {
            val = val.replace(/\n(?!$)/g, "\n");
          } else {
            var indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            if (this._shouldIndent(47) || this.format.retainLines) {
              indentSize += this._getIndent();
            }
            val = val.replace(/\n(?!$)/g, "\n".concat(" ".repeat(indentSize)));
          }
        }
      } else if (!noLineTerminator) {
        val = "//".concat(comment.value);
      } else {
        val = "/*".concat(comment.value, "*/");
      }
      if (this._endsWithDiv) this._space();
      this.source("start", comment.loc);
      this._append(val, isBlockComment);
      if (!isBlockComment && !noLineTerminator) {
        this.newline(1, true);
      }
      if (printNewLines && skipNewLines !== 3) {
        this.newline(1);
      }
    }
  }, {
    key: "_printComments",
    value: function _printComments(type, comments, node, parent) {
      var lineOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var nextToken = arguments.length > 5 ? arguments[5] : undefined;
      var nodeLoc = node.loc;
      var len = comments.length;
      var hasLoc = !!nodeLoc;
      var nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
      var nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
      var lastLine = 0;
      var leadingCommentNewline = 0;
      var maybeNewline = this._noLineTerminator ? function () {} : this.newline.bind(this);
      for (var i = 0; i < len; i++) {
        var comment = comments[i];
        var shouldPrint = this._shouldPrintComment(comment, nextToken);
        if (shouldPrint === 2) {
          hasLoc = false;
          break;
        }
        if (hasLoc && comment.loc && shouldPrint === 1) {
          var commentStartLine = comment.loc.start.line;
          var commentEndLine = comment.loc.end.line;
          if (type === 0) {
            var offset = 0;
            if (i === 0) {
              if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine !== commentEndLine)) {
                offset = leadingCommentNewline = 1;
              }
            } else {
              offset = commentStartLine - lastLine;
            }
            lastLine = commentEndLine;
            maybeNewline(offset);
            this._printComment(comment, 1);
            if (i + 1 === len) {
              maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
              lastLine = nodeStartLine;
            }
          } else if (type === 1) {
            var _offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
            lastLine = commentEndLine;
            maybeNewline(_offset);
            this._printComment(comment, 1);
            if (i + 1 === len) {
              maybeNewline(Math.min(1, nodeEndLine - lastLine));
              lastLine = nodeEndLine;
            }
          } else {
            var _offset2 = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
            lastLine = commentEndLine;
            maybeNewline(_offset2);
            this._printComment(comment, 1);
          }
        } else {
          hasLoc = false;
          if (shouldPrint !== 1) {
            continue;
          }
          if (len === 1) {
            var singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
            var shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumDeclaration(parent);
            if (type === 0) {
              this._printComment(comment, shouldSkipNewline && node.type !== "ObjectExpression" || singleLine && isFunction(parent, {
                body: node
              }) ? 1 : 0);
            } else if (shouldSkipNewline && type === 2) {
              this._printComment(comment, 1);
            } else {
              this._printComment(comment, 0);
            }
          } else if (type === 1 && !(node.type === "ObjectExpression" && node.properties.length > 1) && node.type !== "ClassBody" && node.type !== "TSInterfaceBody") {
            this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
          } else {
            this._printComment(comment, 0);
          }
        }
      }
      if (type === 2 && hasLoc && lastLine) {
        this._lastCommentLine = lastLine;
      }
    }
  }]);
}();
Object.assign(Printer.prototype, generatorFunctions);
{
  Printer.prototype.Noop = function Noop() {};
}
var _default = exports["default"] = Printer;
function commaSeparator(occurrenceCount, last) {
  this.token(",", false, occurrenceCount);
  if (!last) this.space();
}