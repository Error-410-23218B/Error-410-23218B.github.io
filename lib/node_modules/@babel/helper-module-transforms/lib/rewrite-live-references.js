"use strict";

var _templateObject;
function _taggedTemplateLiteral(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = rewriteLiveReferences;
var _core = require("@babel/core");
function isInType(path) {
  do {
    switch (path.parent.type) {
      case "TSTypeAnnotation":
      case "TSTypeAliasDeclaration":
      case "TSTypeReference":
      case "TypeAnnotation":
      case "TypeAlias":
        return true;
      case "ExportSpecifier":
        return path.parentPath.parent.exportKind === "type";
      default:
        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {
          return false;
        }
    }
  } while (path = path.parentPath);
}
function rewriteLiveReferences(programPath, metadata, wrapReference) {
  var imported = new Map();
  var exported = new Map();
  var requeueInParent = function requeueInParent(path) {
    programPath.requeue(path);
  };
  var _iterator = _createForOfIteratorHelper(metadata.source),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        source = _step$value[0],
        data = _step$value[1];
      var _iterator3 = _createForOfIteratorHelper(data.imports),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = _slicedToArray(_step3.value, 2),
            localName = _step3$value[0],
            importName = _step3$value[1];
          imported.set(localName, [source, importName, null]);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      var _iterator4 = _createForOfIteratorHelper(data.importsNamespace),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _localName = _step4.value;
          imported.set(_localName, [source, null, _localName]);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var _iterator2 = _createForOfIteratorHelper(metadata.local),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _exportMeta;
      var _step2$value = _slicedToArray(_step2.value, 2),
        local = _step2$value[0],
        _data = _step2$value[1];
      var exportMeta = exported.get(local);
      if (!exportMeta) {
        exportMeta = [];
        exported.set(local, exportMeta);
      }
      (_exportMeta = exportMeta).push.apply(_exportMeta, _toConsumableArray(_data.names));
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  var rewriteBindingInitVisitorState = {
    metadata: metadata,
    requeueInParent: requeueInParent,
    scope: programPath.scope,
    exported: exported
  };
  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);
  var rewriteReferencesVisitorState = {
    seen: new WeakSet(),
    metadata: metadata,
    requeueInParent: requeueInParent,
    scope: programPath.scope,
    imported: imported,
    exported: exported,
    buildImportReference: function buildImportReference(_ref, identNode) {
      var _ref2 = _slicedToArray(_ref, 3),
        source = _ref2[0],
        importName = _ref2[1],
        localName = _ref2[2];
      var meta = metadata.source.get(source);
      meta.referenced = true;
      if (localName) {
        if (meta.wrap) {
          var _wrapReference;
          identNode = (_wrapReference = wrapReference(identNode, meta.wrap)) != null ? _wrapReference : identNode;
        }
        return identNode;
      }
      var namespace = _core.types.identifier(meta.name);
      if (meta.wrap) {
        var _wrapReference2;
        namespace = (_wrapReference2 = wrapReference(namespace, meta.wrap)) != null ? _wrapReference2 : namespace;
      }
      if (importName === "default" && meta.interop === "node-default") {
        return namespace;
      }
      var computed = metadata.stringSpecifiers.has(importName);
      return _core.types.memberExpression(namespace, computed ? _core.types.stringLiteral(importName) : _core.types.identifier(importName), computed);
    }
  };
  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);
}
var rewriteBindingInitVisitor = {
  Scope: function Scope(path) {
    path.skip();
  },
  ClassDeclaration: function ClassDeclaration(path) {
    var requeueInParent = this.requeueInParent,
      exported = this.exported,
      metadata = this.metadata;
    var id = path.node.id;
    if (!id) throw new Error("Expected class to have a name");
    var localName = id.name;
    var exportNames = exported.get(localName) || [];
    if (exportNames.length > 0) {
      var statement = _core.types.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, _core.types.identifier(localName), path.scope));
      statement._blockHoist = path.node._blockHoist;
      requeueInParent(path.insertAfter(statement)[0]);
    }
  },
  VariableDeclaration: function VariableDeclaration(path) {
    var requeueInParent = this.requeueInParent,
      exported = this.exported,
      metadata = this.metadata;
    var isVar = path.node.kind === "var";
    var _iterator5 = _createForOfIteratorHelper(path.get("declarations")),
      _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var decl = _step5.value;
        var id = decl.node.id;
        var init = decl.node.init;
        if (_core.types.isIdentifier(id) && exported.has(id.name) && !_core.types.isArrowFunctionExpression(init) && (!_core.types.isFunctionExpression(init) || init.id) && (!_core.types.isClassExpression(init) || init.id)) {
          if (!init) {
            if (isVar) {
              continue;
            } else {
              init = path.scope.buildUndefinedNode();
            }
          }
          decl.node.init = buildBindingExportAssignmentExpression(metadata, exported.get(id.name), init, path.scope);
          requeueInParent(decl.get("init"));
        } else {
          for (var _i = 0, _Object$keys = Object.keys(decl.getOuterBindingIdentifiers()); _i < _Object$keys.length; _i++) {
            var localName = _Object$keys[_i];
            if (exported.has(localName)) {
              var statement = _core.types.expressionStatement(buildBindingExportAssignmentExpression(metadata, exported.get(localName), _core.types.identifier(localName), path.scope));
              statement._blockHoist = path.node._blockHoist;
              requeueInParent(path.insertAfter(statement)[0]);
            }
          }
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
  }
};
var buildBindingExportAssignmentExpression = function buildBindingExportAssignmentExpression(metadata, exportNames, localExpr, scope) {
  var exportsObjectName = metadata.exportName;
  for (var currentScope = scope; currentScope != null; currentScope = currentScope.parent) {
    if (currentScope.hasOwnBinding(exportsObjectName)) {
      currentScope.rename(exportsObjectName);
    }
  }
  return (exportNames || []).reduce(function (expr, exportName) {
    var stringSpecifiers = metadata.stringSpecifiers;
    var computed = stringSpecifiers.has(exportName);
    return _core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportsObjectName), computed ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), computed), expr);
  }, localExpr);
};
var buildImportThrow = function buildImportThrow(localName) {
  return _core.template.expression.ast(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    (function() {\n      throw new Error('\"' + '", "' + '\" is read-only.');\n    })()\n  "])), localName);
};
var rewriteReferencesVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path) {
    var seen = this.seen,
      buildImportReference = this.buildImportReference,
      scope = this.scope,
      imported = this.imported,
      requeueInParent = this.requeueInParent;
    if (seen.has(path.node)) return;
    seen.add(path.node);
    var localName = path.node.name;
    var importData = imported.get(localName);
    if (importData) {
      if (isInType(path)) {
        throw path.buildCodeFrameError("Cannot transform the imported binding \"".concat(localName, "\" since it's also used in a type annotation. ") + "Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.");
      }
      var localBinding = path.scope.getBinding(localName);
      var rootBinding = scope.getBinding(localName);
      if (rootBinding !== localBinding) return;
      var ref = buildImportReference(importData, path.node);
      ref.loc = path.node.loc;
      if ((path.parentPath.isCallExpression({
        callee: path.node
      }) || path.parentPath.isOptionalCallExpression({
        callee: path.node
      }) || path.parentPath.isTaggedTemplateExpression({
        tag: path.node
      })) && _core.types.isMemberExpression(ref)) {
        path.replaceWith(_core.types.sequenceExpression([_core.types.numericLiteral(0), ref]));
      } else if (path.isJSXIdentifier() && _core.types.isMemberExpression(ref)) {
        var object = ref.object,
          property = ref.property;
        path.replaceWith(_core.types.jsxMemberExpression(_core.types.jsxIdentifier(object.name), _core.types.jsxIdentifier(property.name)));
      } else {
        path.replaceWith(ref);
      }
      requeueInParent(path);
      path.skip();
    }
  },
  UpdateExpression: function UpdateExpression(path) {
    var scope = this.scope,
      seen = this.seen,
      imported = this.imported,
      exported = this.exported,
      requeueInParent = this.requeueInParent,
      buildImportReference = this.buildImportReference;
    if (seen.has(path.node)) return;
    seen.add(path.node);
    var arg = path.get("argument");
    if (arg.isMemberExpression()) return;
    var update = path.node;
    if (arg.isIdentifier()) {
      var localName = arg.node.name;
      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
        return;
      }
      var exportedNames = exported.get(localName);
      var importData = imported.get(localName);
      if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
        if (importData) {
          path.replaceWith(_core.types.assignmentExpression(update.operator[0] + "=", buildImportReference(importData, arg.node), buildImportThrow(localName)));
        } else if (update.prefix) {
          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.cloneNode(update), path.scope));
        } else {
          var ref = scope.generateDeclaredUidIdentifier(localName);
          path.replaceWith(_core.types.sequenceExpression([_core.types.assignmentExpression("=", _core.types.cloneNode(ref), _core.types.cloneNode(update)), buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.identifier(localName), path.scope), _core.types.cloneNode(ref)]));
        }
      }
    }
    requeueInParent(path);
    path.skip();
  },
  AssignmentExpression: {
    exit: function exit(path) {
      var _this = this;
      var scope = this.scope,
        seen = this.seen,
        imported = this.imported,
        exported = this.exported,
        requeueInParent = this.requeueInParent,
        buildImportReference = this.buildImportReference;
      if (seen.has(path.node)) return;
      seen.add(path.node);
      var left = path.get("left");
      if (left.isMemberExpression()) return;
      if (left.isIdentifier()) {
        var localName = left.node.name;
        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
          return;
        }
        var exportedNames = exported.get(localName);
        var importData = imported.get(localName);
        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
          var assignment = path.node;
          if (importData) {
            assignment.left = buildImportReference(importData, left.node);
            assignment.right = _core.types.sequenceExpression([assignment.right, buildImportThrow(localName)]);
          }
          var operator = assignment.operator;
          var newExpr;
          if (operator === "=") {
            newExpr = assignment;
          } else if (operator === "&&=" || operator === "||=" || operator === "??=") {
            newExpr = _core.types.assignmentExpression("=", assignment.left, _core.types.logicalExpression(operator.slice(0, -1), _core.types.cloneNode(assignment.left), assignment.right));
          } else {
            newExpr = _core.types.assignmentExpression("=", assignment.left, _core.types.binaryExpression(operator.slice(0, -1), _core.types.cloneNode(assignment.left), assignment.right));
          }
          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, newExpr, path.scope));
          requeueInParent(path);
          path.skip();
        }
      } else {
        var ids = left.getOuterBindingIdentifiers();
        var programScopeIds = Object.keys(ids).filter(function (localName) {
          return scope.getBinding(localName) === path.scope.getBinding(localName);
        });
        var id = programScopeIds.find(function (localName) {
          return imported.has(localName);
        });
        if (id) {
          path.node.right = _core.types.sequenceExpression([path.node.right, buildImportThrow(id)]);
        }
        var items = [];
        programScopeIds.forEach(function (localName) {
          var exportedNames = exported.get(localName) || [];
          if (exportedNames.length > 0) {
            items.push(buildBindingExportAssignmentExpression(_this.metadata, exportedNames, _core.types.identifier(localName), path.scope));
          }
        });
        if (items.length > 0) {
          var node = _core.types.sequenceExpression(items);
          if (path.parentPath.isExpressionStatement()) {
            node = _core.types.expressionStatement(node);
            node._blockHoist = path.parentPath.node._blockHoist;
          }
          var statement = path.insertAfter(node)[0];
          requeueInParent(statement);
        }
      }
    }
  },
  ForXStatement: function ForXStatement(path) {
    var scope = path.scope,
      node = path.node;
    var left = node.left;
    var exported = this.exported,
      imported = this.imported,
      programScope = this.scope;
    if (!_core.types.isVariableDeclaration(left)) {
      var didTransformExport = false,
        importConstViolationName;
      var loopBodyScope = path.get("body").scope;
      for (var _i2 = 0, _Object$keys2 = Object.keys(_core.types.getOuterBindingIdentifiers(left)); _i2 < _Object$keys2.length; _i2++) {
        var name = _Object$keys2[_i2];
        if (programScope.getBinding(name) === scope.getBinding(name)) {
          if (exported.has(name)) {
            didTransformExport = true;
            if (loopBodyScope.hasOwnBinding(name)) {
              loopBodyScope.rename(name);
            }
          }
          if (imported.has(name) && !importConstViolationName) {
            importConstViolationName = name;
          }
        }
      }
      if (!didTransformExport && !importConstViolationName) {
        return;
      }
      path.ensureBlock();
      var bodyPath = path.get("body");
      var newLoopId = scope.generateUidIdentifierBasedOnNode(left);
      path.get("left").replaceWith(_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(newLoopId))]));
      scope.registerDeclaration(path.get("left"));
      if (didTransformExport) {
        bodyPath.unshiftContainer("body", _core.types.expressionStatement(_core.types.assignmentExpression("=", left, newLoopId)));
      }
      if (importConstViolationName) {
        bodyPath.unshiftContainer("body", _core.types.expressionStatement(buildImportThrow(importConstViolationName)));
      }
    }
  }
};