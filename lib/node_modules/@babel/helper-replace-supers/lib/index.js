"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _templateObject, _templateObject2, _templateObject3, _templateObject4;
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _taggedTemplateLiteral(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _helperMemberExpressionToFunctions = require("@babel/helper-member-expression-to-functions");
var _helperOptimiseCallExpression = require("@babel/helper-optimise-call-expression");
var _core = require("@babel/core");
var _traverse = require("@babel/traverse");
var _core$types = _core.types,
  assignmentExpression = _core$types.assignmentExpression,
  callExpression = _core$types.callExpression,
  cloneNode = _core$types.cloneNode,
  identifier = _core$types.identifier,
  memberExpression = _core$types.memberExpression,
  sequenceExpression = _core$types.sequenceExpression,
  stringLiteral = _core$types.stringLiteral,
  thisExpression = _core$types.thisExpression;
{
  exports.environmentVisitor = _traverse.visitors.environmentVisitor({});
  exports.skipAllButComputedKey = function skipAllButComputedKey(path) {
    path.skip();
    if (path.node.computed) {
      path.context.maybeQueue(path.get("key"));
    }
  };
}
var visitor = _traverse.visitors.environmentVisitor({
  Super: function Super(path, state) {
    var node = path.node,
      parentPath = path.parentPath;
    if (!parentPath.isMemberExpression({
      object: node
    })) return;
    state.handle(parentPath);
  }
});
var unshadowSuperBindingVisitor = _traverse.visitors.environmentVisitor({
  Scopable: function Scopable(path, _ref) {
    var refName = _ref.refName;
    var binding = path.scope.getOwnBinding(refName);
    if (binding && binding.identifier.name === refName) {
      path.scope.rename(refName);
    }
  }
});
var specHandlers = {
  memoise: function memoise(superMember, count) {
    var scope = superMember.scope,
      node = superMember.node;
    var computed = node.computed,
      property = node.property;
    if (!computed) {
      return;
    }
    var memo = scope.maybeGenerateMemoised(property);
    if (!memo) {
      return;
    }
    this.memoiser.set(property, memo, count);
  },
  prop: function prop(superMember) {
    var _superMember$node = superMember.node,
      computed = _superMember$node.computed,
      property = _superMember$node.property;
    if (this.memoiser.has(property)) {
      return cloneNode(this.memoiser.get(property));
    }
    if (computed) {
      return cloneNode(property);
    }
    return stringLiteral(property.name);
  },
  _getPrototypeOfExpression: function _getPrototypeOfExpression() {
    var objectRef = cloneNode(this.getObjectRef());
    var targetRef = this.isStatic || this.isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
    return callExpression(this.file.addHelper("getPrototypeOf"), [targetRef]);
  },
  get: function get(superMember) {
    var objectRef = cloneNode(this.getObjectRef());
    return callExpression(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), objectRef]) : objectRef, this.prop(superMember), thisExpression()].concat(_toConsumableArray(this.isStatic || this.isPrivateMethod ? [] : [_core.types.numericLiteral(1)])));
  },
  _call: function _call(superMember, args, optional) {
    var objectRef = cloneNode(this.getObjectRef());
    var argsNode;
    if (args.length === 1 && _core.types.isSpreadElement(args[0]) && (_core.types.isIdentifier(args[0].argument) || _core.types.isArrayExpression(args[0].argument))) {
      argsNode = args[0].argument;
    } else {
      argsNode = _core.types.arrayExpression(args);
    }
    var call = _core.types.callExpression(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), objectRef]) : objectRef, this.prop(superMember), thisExpression(), _core.types.numericLiteral(2 | (this.isStatic || this.isPrivateMethod ? 0 : 1))]);
    if (optional) {
      return _core.types.optionalCallExpression(call, [argsNode], true);
    }
    return callExpression(call, [argsNode]);
  },
  set: function set(superMember, value) {
    var objectRef = cloneNode(this.getObjectRef());
    return callExpression(this.file.addHelper("superPropSet"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), objectRef]) : objectRef, this.prop(superMember), value, thisExpression(), _core.types.numericLiteral(superMember.isInStrictMode() ? 1 : 0)].concat(_toConsumableArray(this.isStatic || this.isPrivateMethod ? [] : [_core.types.numericLiteral(1)])));
  },
  destructureSet: function destructureSet(superMember) {
    throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
  },
  call: function call(superMember, args) {
    return this._call(superMember, args, false);
  },
  optionalCall: function optionalCall(superMember, args) {
    return this._call(superMember, args, true);
  },
  "delete": function _delete(superMember) {
    if (superMember.node.computed) {
      return sequenceExpression([callExpression(this.file.addHelper("toPropertyKey"), [cloneNode(superMember.node.property)]), _core.template.expression.ast(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n          function () { throw new ReferenceError(\"'delete super[expr]' is invalid\"); }()\n        "])))]);
    } else {
      return _core.template.expression.ast(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n        function () { throw new ReferenceError(\"'delete super.prop' is invalid\"); }()\n      "])));
    }
  }
};
var specHandlers_old = {
  memoise: function memoise(superMember, count) {
    var scope = superMember.scope,
      node = superMember.node;
    var computed = node.computed,
      property = node.property;
    if (!computed) {
      return;
    }
    var memo = scope.maybeGenerateMemoised(property);
    if (!memo) {
      return;
    }
    this.memoiser.set(property, memo, count);
  },
  prop: function prop(superMember) {
    var _superMember$node2 = superMember.node,
      computed = _superMember$node2.computed,
      property = _superMember$node2.property;
    if (this.memoiser.has(property)) {
      return cloneNode(this.memoiser.get(property));
    }
    if (computed) {
      return cloneNode(property);
    }
    return stringLiteral(property.name);
  },
  _getPrototypeOfExpression: function _getPrototypeOfExpression() {
    var objectRef = cloneNode(this.getObjectRef());
    var targetRef = this.isStatic || this.isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
    return callExpression(this.file.addHelper("getPrototypeOf"), [targetRef]);
  },
  get: function get(superMember) {
    return this._get(superMember);
  },
  _get: function _get(superMember) {
    var proto = this._getPrototypeOfExpression();
    return callExpression(this.file.addHelper("get"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), proto]) : proto, this.prop(superMember), thisExpression()]);
  },
  set: function set(superMember, value) {
    var proto = this._getPrototypeOfExpression();
    return callExpression(this.file.addHelper("set"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), proto]) : proto, this.prop(superMember), value, thisExpression(), _core.types.booleanLiteral(superMember.isInStrictMode())]);
  },
  destructureSet: function destructureSet(superMember) {
    throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
  },
  call: function call(superMember, args) {
    return (0, _helperOptimiseCallExpression["default"])(this._get(superMember), thisExpression(), args, false);
  },
  optionalCall: function optionalCall(superMember, args) {
    return (0, _helperOptimiseCallExpression["default"])(this._get(superMember), cloneNode(thisExpression()), args, true);
  },
  "delete": function _delete(superMember) {
    if (superMember.node.computed) {
      return sequenceExpression([callExpression(this.file.addHelper("toPropertyKey"), [cloneNode(superMember.node.property)]), _core.template.expression.ast(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n          function () { throw new ReferenceError(\"'delete super[expr]' is invalid\"); }()\n        "])))]);
    } else {
      return _core.template.expression.ast(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n        function () { throw new ReferenceError(\"'delete super.prop' is invalid\"); }()\n      "])));
    }
  }
};
var looseHandlers = Object.assign({}, specHandlers, {
  prop: function prop(superMember) {
    var property = superMember.node.property;
    if (this.memoiser.has(property)) {
      return cloneNode(this.memoiser.get(property));
    }
    return cloneNode(property);
  },
  get: function get(superMember) {
    var isStatic = this.isStatic,
      getSuperRef = this.getSuperRef;
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    var object;
    if (isStatic) {
      var _getSuperRef;
      object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier("Function"), identifier("prototype"));
    } else {
      var _getSuperRef2;
      object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier("Object"), identifier("prototype"));
    }
    return memberExpression(object, prop, computed);
  },
  set: function set(superMember, value) {
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    return assignmentExpression("=", memberExpression(thisExpression(), prop, computed), value);
  },
  destructureSet: function destructureSet(superMember) {
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    return memberExpression(thisExpression(), prop, computed);
  },
  call: function call(superMember, args) {
    return (0, _helperOptimiseCallExpression["default"])(this.get(superMember), thisExpression(), args, false);
  },
  optionalCall: function optionalCall(superMember, args) {
    return (0, _helperOptimiseCallExpression["default"])(this.get(superMember), thisExpression(), args, true);
  }
});
var ReplaceSupers = /*#__PURE__*/function () {
  function ReplaceSupers(opts) {
    _classCallCheck(this, ReplaceSupers);
    var _opts$constantSuper;
    var path = opts.methodPath;
    this.methodPath = path;
    this.isDerivedConstructor = path.isClassMethod({
      kind: "constructor"
    }) && !!opts.superRef;
    this.isStatic = path.isObjectMethod() || path.node["static"] || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());
    this.isPrivateMethod = path.isPrivate() && path.isMethod();
    this.file = opts.file;
    this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;
    this.opts = opts;
  }
  return _createClass(ReplaceSupers, [{
    key: "getObjectRef",
    value: function getObjectRef() {
      return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
    }
  }, {
    key: "getSuperRef",
    value: function getSuperRef() {
      if (this.opts.superRef) return cloneNode(this.opts.superRef);
      if (this.opts.getSuperRef) {
        return cloneNode(this.opts.getSuperRef());
      }
    }
  }, {
    key: "replace",
    value: function replace() {
      var methodPath = this.methodPath;
      if (this.opts.refToPreserve) {
        methodPath.traverse(unshadowSuperBindingVisitor, {
          refName: this.opts.refToPreserve.name
        });
      }
      var handler = this.constantSuper ? looseHandlers : this.file.availableHelper("superPropSet") ? specHandlers : specHandlers_old;
      visitor.shouldSkip = function (path) {
        if (path.parentPath === methodPath) {
          if (path.parentKey === "decorators" || path.parentKey === "key") {
            return true;
          }
        }
      };
      (0, _helperMemberExpressionToFunctions["default"])(methodPath, visitor, Object.assign({
        file: this.file,
        scope: this.methodPath.scope,
        isDerivedConstructor: this.isDerivedConstructor,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        getSuperRef: this.getSuperRef.bind(this),
        boundGet: handler.get
      }, handler));
    }
  }]);
}();
exports["default"] = ReplaceSupers;